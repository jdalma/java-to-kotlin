
자바와 코틀린의 큰 차이는
1. 널 허용성 여부
2. 일반 함수 또는 람다 함수를 일반 변수에 담을 수 있고 파라미터로 전달하거나 반환할 수 있음
3. 예외를 `Result`와 같이 값으로 반환
4. 클래스로 캡슐화를 하기 보다는 코틀린 표준 라이브러리를 사용하기 위한 타입 별명 적용
5. 코드 트랜잭션은 가능한 짧게 작성하기
6. 함수 체이닝
7. 인라인 함수 (컴파일 시점에 함수 본문의 바이트코드를 삽입하여 준다.)
8. 코틀린은 기본적으로 클래스 상속에 닫혀있고, 합성적인 스타일을 장려

```
"리팩터링을 하고 싶다면, 필수 전제조건은 탄탄한 테스트가 있어야 한다." 
- 마틴 파울러
```

> 코틀린은 `가변성` + `OOP`를 바탕에 깔고 있는 언어이기 때문에 아에 가변성을 쓰지 않을 이유는 없다
> 
> 1. 전체적인 프로젝트의 흐름은 객체지향을 쓴다
> 2. 객체지향을 쓸 때도 꼭 필요한 경우가 아니라면 가변 필드 + 가변 객체를 쓰는 일은 지양한다
> 3. 객체 사이의 통신에 사용하는 메서드는 가능하면 명시적 수단 (파라미터와 반환 값을 사용)을 활용하고 부수효과(side effect)를 만들지 않는다
> 4. 한 함수 / 메서드 내부에는 가능한 불변성을 활용한다
> 5. 여러 원소를 저장할 컬렉션에 대한 집계, 필터링, 변환 등의 로직을 직접 구현하기 보다는 표준 컬렉션 라이브러리를 활용한다
>
> 상태를 경계에 잘 가둬서 처리하느냐 → **객체지향**    
> 상태 변화를 없애고 상태라는 걸 값을 가지고 애뮬레이션 하느냐 → **함수형**  
> 함수 경계 안에서는 불변객체와 컬렉션을 쓰고 각종 순수 함수를 도우미로 써서 함수형으로 처리하면 좀 더 코드를 쉽게 작성할 수 있고,    
> 전체적으로는 객체지향적으로 사고하면서 모듈간의 결합도를 최소화하고 응집도를 최대하한다는 기본 원칙을 지켜나가는 스타일이 이미 자바 개발자인 분들에게는 최선이 될 것이다.    
> - 자바에서 코틀린으로 옮긴이 [오현석](http://www.yes24.com/24/AuthorFile/Author/192002)


> 값 컨텍스트로 프로그래밍하면 그 여파가 미치는 곳은 코드의 디자인적인 측면이나 설계까지 전부 영향이가고,    
> 더 나아가 코드를 사용하는 방법 마저도 달라지고 필요한 자료구조도 달라진다.    
> 단지 저장에 해당되는 부분만 값으로 대치한다고 끝이 아니다. 값 컨텍스트를 도입하려면 값을 다루는 모든 프로그래밍 스킬도 배워야 한다.   
> 값과 함수형을 고려할 때는 조직 내 사람이라는 문제를 간과하지 않아야 한다.    
> 값 컨텍스트를 펼치고 함수형 프로그래밍을 팁에 도입한뒤 "넌 이거 왜 못해?"라고 하는 것은 폭력이 될 수 있다.
> - [맹기완](https://www.rocketpunch.com/@hikamaeng) 대표

## 무지 목록

- **값 의미론**
  - 객체 사이의 동등성이 객체의 정체성(=물리적 주소)에 의해 결정되지 않고 **객체 내의 필드 값에 의해 결정되는게 값 의미론**
- [`kotlinlang docs` 확장 프로그램](https://kotlinlang.org/docs/extensions.html)
- `@JvmStatic`, `@JvmOverloads`
  - `@JvmStatic` 자바 클래스로 변환될 때 스태틱 메소드를 만들어준다. 
- `inline fun require(value: Boolean, lazyMessage: () -> Any): Unit`
- **호출 연산자 `!!.` , `?.`**
  - 실전에서 `!!`을 사용하는 몇 안되는 경우가 바로 테스트다.
- **단일식 함수 구문의 장단점**
- **엘비스 연산자 `?:`**
- **`Standard.kt`** 내부 `inline fun` 분석
- **불변 객체를 쓰면 되돌리기나 다시하기 등도 쉽게 구현할 수 있다.**
- [ADT Types](https://www.geeksforgeeks.org/abstract-data-types/)
- **인스턴스 컨텍스트**
- **수신 객체 지정 람다**
- **[Aliasing Error](https://martinfowler.com/bliki/AliasingBug.html)**
- **[테스트로 인한 설계 손상](https://dhh.dk/2014/test-induced-design-damage.html)**
- `Arrays.sort()`와 `Collections.sort()`차이  
- `asSequence()`
- `@file:JvmName`
- [`kotlinlang` constructors](https://kotlinlang.org/docs/classes.html#constructors)
- `data class`는 `static` 함수를 포함할 수 없나?
  - `private`필드는 `getter`가 생성되지 않는다.
  - 필드에 대입만해도 코틀린 컴파일러가 해당 필드의 `setter`를 호출한다
- 필드 뒤에 `private set`키워드를 추가한다면 `getter`만 노출된다
- `by` 키워드
  - 생성자 인자로 받은 객체의 인터페이스 모든 메서드를 전달한다고 선언하는 것
- `runCatching...onFailure`와 `try...catch`의 차이점
- `@Throws`
  - 코틀린은 체크 예외를 제공하지 않지만, 이 애너테이션을 사용하여 바이트 코드로 생성되는 메서드 시그니처에 예외를 추가해서 자바와의 상호 운용할 수 있다.
- `Sequence`에는 상태가 들어있기 때문에 값이 아니지만??
- `Iterable<T>.zip`
- `Collection<*>.indices`

***

# **1장. 소개**

## 코틀린의 결

코틀린에서 `함수`와 `데이터`는 그 자체로 **독립적인 1급 기능**이며 클래스의 멤버로 선언될 필요가 없다.  
코틀린에서 가장 매력적인 기능은 **타입 시스템에서 널 가능성을 표현하는 능력**일 것이다.  
  
코틀린의 결은 **표준 라이브러리가 제공하는 풍부한 추상화를 활용하는 것과 궤를 같이하지만, 자바의 결은 새 타입을 정의하는 쪽에 더 가깝다.**  
  
- [왜 코틀린인가?](https://kotlinlang.org/#why-kotlin) 
   - 간결성
   - 안전성
   - 상호 운용성
   - 도구 친화성

1. **코틀린은 가변 상태를 변경하는 것보다 불변 데이터를 변환하는 쪽을 더 선호한다.**
   - 데이터 클래스를 사용하며 `값 의미론`을 제공하는 새로운 타입을 쉽게 정의할 수 있다.
2. **코틀린은 동작을 명시적으로 작성하는 쪽을 더 선호한다.**
   - 코틀린에는 암시적인 타입 변환이 없다.
   - 심지어 더 작은 데이터 타입을 더 큰 데이터 타입으로 자동으로 변환해 주지도 않는다.
     - 자바는 정보 손실이 없으므로 `int`를 `long`으로 암시적으로 변환해 주지만,
     - 코틀린에서는 `Int.toLong()`을 명시적으로 호출해야한다.
   - `명시성`을 선호하는 경향은 **흐름 제어에서 더 강하다.**
3. **코틀린은 동적 바인딩보다 정적 바인딩을 더 선호한다.**
   - 코틀린은 `타입 안전한`, `합성적인 코딩 스타일`을 장려한다.
   - **확장 함수**는 정적으로 바인딩된다. ❓
   - 기본적으로 클래스는 확장될 수 없고, 메서드는 다형적이지 않다.
   - **명시적으로 다형성과 상속을 활성화해야 한다.** 📌
4. **코틀린은 특별한 경우를 좋아하지 않는다.**
   - **원시 타입과 참조 타입 사이에 구분이 없다.**
   - 반환 시 아무 값도 돌려주지 않는 함수에 대한 `void`타입도 없다.
   - **확장 함수**를 사용하면 기존 타입에 새로운 연산을 추가할 수 있고,
     - 호출하는 쪽의 코드에서는 기존 연산과 확장 함수를 구분할 수 없다.
     - 인라인 함수를 사용해 새로운 제어 구조를 작성할 수도 있다.
5. **코틀린은 마이그레이션을 쉽게 하기 위해 자신의 규칙을 깬다.**
   - 코틀린 언어에는 숙어처럼 사용하는 자바와 코틀린 코드가 동시에 존재하도록 허용하기 위한 기능이 들어있다.
   - 어떤 프로퍼티를 `lateinit var`로 선언하면 이 값을 초기화할 책임은 개발자에게 있다.

## 코틀린으로 리팩토링하기

### [git bisect](https://git-scm.com/docs/git-bisect/)를 고려해 커밋한다.

커밋 이력이 아주 크고, 서로 무관한 변경 사항이 이리저리 섞여 있다면 `git bisect`가 큰 도움이 되지 않는다.  
따라서 각 리팩토링과 행동 변경을 서로 분리할 수 있도록 작게 커밋한다.  

***

# **2장. 자바 프로젝트에서 코틀린 프로젝트로**

## 전략

**자바의 한계**  
1. 불변 값 타입을 구현하기 위해 필요한 장황한 코드
2. 원시 타입과 참조 타입의 분리
3. 널 참조
4. 일반적인 고차 함수지원이 부족한 스트림
등등..

***

# **3장. 자바 클래스에서 코틀린 클래스로**

1. **생성자 파라미터를 한 줄에 하나씩 배치하기**
2. 코틀린 클래스 정의에는 `클래스 이름` , `주 생성자` , `상위 클래스` , `인터페이스`
   - 주 생성자안에는 파라미터와 프로퍼티 정의가 있을 수 있다.
   - 상위 클래스 뒤에 괄호를 붙여서 상위 클래스 생성자를 호출할 수도 있다.
   - 클래스 본문에서 프로퍼티와 생성자를 추가로 정의할 수 있다.
   - **동반 객체(Companion Object)** 도 본문에 들어간다.

## 데이터 클래스의 한계

**클래스 앞에 `data` (변경자)를 붙이면 컴파일러가 사용자가 정의하지 않은 `equals`, `hashCode`, `toString`, `copy` 메서드를 자동으로 대신 생성해 준다.**  
하지만 **데이터 클래스는 캡슐화를 제공하지 않는다.**  

`copy()`
- 데이터 클래스 객체의 모든 프로퍼티 값을 그대로 복사한 새 객체를 생성하되,
- 원하면 일부를 다른 값으로 대치할 수 있다.
- 유용한 메서드 이지만 **값의 내부 상태에 직접 접근하도록 허용해서 불변 조건을 깰 수 있다.**

비즈니스 로직에서 중간 결과를 저장하거나,  
데이터를 임시 구조에 담아서 애플리케이션 로직을 더 쉽게 작성할 수 있게 할 때 사용하긴 한다.  

하지만 값 타입이 불변 조건을 유지해야 하거나 내부 표현을 캡슐화해야 한다면 데이터 클래스가 적합하지 않다.  
이런 경우에는 **직접 값 의미론을 구현해야 한다.**  
**프로퍼티 사이에 불변 조건을 유지해야 하는 값 타입들은 데이터 클래스를 사용해 정의하지 말라**

## BigDecimal

`BigDecimal.setScale()`은 혼란을 일으킬 수 있다.  
세터처럼 보이지만 실제로 `BigDecimal`객체의 상태를 변경하지는 않는다.  
`setScale()`은 새로 설정한 정밀도에 맞춘 **새 BigDecimal을 반환**한다.  

요즘은 객체 상태를 변화시키지 않는 메서드에 `set`이라는 접두사를 붙이는 것을 피하는 대신 메서드가 객체를 변환한 새 객체를 돌려준다는 사실을 강조하는 이름을 사용한다.  
일반적인 관습은 프로퍼티 하나에만 영향을 끼치는 경우 `with`접두사를 사용하는 것이다.  

```java
// 기존
amount.setScale(currency.getDefaultFractionDigits());

// 아래와 같았으면 좋았겠지
amount.withScale(currency.getDefaultFractionDigits());
```

`BigDecimal`을 사용하는 코드를 아주 많이 사용해야 한다면, 아래와 같은 메서드를 추가할 만한 가치가 있다.  
```kotlin
fun BigDecimal.withScale(int scale, RoundingMode mode) = setScale(scale, mode)
```

***

# **4장. 옵셔널에서 널이 될 수 있는 타입으로**

코틀린은 **널을 포용**한다.  
함수형 프로그래머들은 코틀린의 널 가능성 대신 옵셔널 타입(또는 **메이비**타입)을 사용하라고 권장하지만,  
코틀린에서 `Optinal`을 쓰면 안되는 한 가지 이유는 **널 가능성을 지원하기 위해 구체적으로 설계된 언어 기능을 쓰지 못 하게 된다는 점**에 있다.  

코틀린 타입 시스템에서 `T`는 `T?`의 하위 타입이다.  
반대로 `T`는 `Optional<T>`의 하위 타입이 아니다.  
`Optional<String>`을 반환하는 함수가 있는데 반환 타입을 `String`으로 바꾼다면 모든 클라이언트 코드가 깨져버린다.  
**반환 타입이 `String?`이었다면 그냥 그 타입을 `String`으로 변경해도 호환성이 유지될 수 있다.**  

**널 가능성**을 사용하면 선택적인 값을 선택적이지 않은 값으로 쉽게 변경할 수 있지만,  
`Optional`을 사용하면 이런 변경이 쉽지 않다.

## 옵셔널에서 널 가능성으로 리팩토링 하기

코틀린 함수에서 널이 될 수 없는 파라미터를 지정하면 컴파일러가 함수 본문 이전에 널 검사를 추가해준다. **(컴파일 코드에 없는 것 같은데..)** 

```kotlin
@kotlin.jvm.JvmStatic 
public final fun findLongestLegOver(
    legs: kotlin.collections.List<travelator.Leg>, 
    duration: java.time.Duration
): java.util.Optional<travelator.Leg> { /* compiled code */ }
```

`Optional<Leg>`와 `Leg?`를 반환하는 함수를 비교해보자 [`LongestLegOverTests.kt` 예제 코드](https://github.com/jdalma/java-to-kotlin/commit/fa38dd02ee91179300935e9284e2d090022735a5)  
자바 클라이언트는 `Optional<Leg>`를 반환하는 `findLongestLegOver()`를 사용   
코틀린 클라이언트는 널이 될 수 있는 `Leg?`를 반환하는 `longestLegOver()`를 사용  



### **이터레이션과 `for`루프**

코틀린에서는 `Iterable`이 아닌 다른 타입을 `for`루프에 사용할 수도 있다.
- [`jdalma` Java Iterator, Enumerator, Iterable ?](https://jdalma.github.io/docs/lab/iterator_vs_enumeration/)

1. `Iterable`을 확장하는 타입
2. `Iterator`를 반환하는 `iterator()` 제공하는 타입
3. `Iterator`를 반환하는  `T.iterator()` 확장 함수가 영역 안에 정의된 `T 타입`

- 코틀린의 `Iterator`와 `Iterable`은 자바의 호환성을 위해서만 존재한다  
  - `Opreator.next()`와 `Opreator.hasNext()`로도 구분한다  

두 번째와 세 번째 방식은 해당 타입을 `Iterable`로 만들어 주지는 못하며, 코틀린 `for`루프만 적용할 수 있을 뿐이다.  

## 코틀린다운 코드로 리팩토링 하기 [예제 코드](https://github.com/jdalma/java-to-kotlin/commit/8000db5ab59dd98cd64b08c096c089a49662dde6)

코틀린에서는 추가적인 `네임스페이스`가 필요없다.    
`Move to top leve (최상위로 옮기기)`를 `longestLegOver`에 적용할 수 있다.  

***

# **5장. 가변 객체를 불변 데이터로**

이번 5장에서는 클라이언트가 전달하는 `UserPreferences` 가변 객체에 대한 불변 참조를 **불변 객체에 대한 가변 참조로 바꾸는 것**이다.    
객체는 **가변 상태를 관리하는 문제에 대한 해결책 이었다.**    

여기서 **값**이라고 말하면 **값 의미론**을 따르는 `구체적인 원시 타입`이나 `참조 타입`을 뜻한다.  
- 자바 원시 타입 값은 모두 **값 의미론**을 따른다.

**값**은 `불변 데이터 조각`으로 정의하고  
**값 타입**은 `불변 데이터 조각의 동작을 정의하는 타입`으로 정의하자

Integer는 값 타입, 7은 값이다.  

## 값을 선호해야만 하는 이유는 무엇인가?

값은 `불변 데이터`다.  

1. 맵의 키나 집합 원소로 불변 객체를 넣을 수 있다.
2. 불변 객체의 컬렉션에 대해 이터레이션하는 경우 내부 원소가 달라질지 염려할 필요가 없다.
3. 불변 객체를 쓰면 되돌리기나 다시하기 등도 쉽게 구현할 수 있다. ❓
4. 여러 스레드에서 불변 객체를 **읽기 전용**으로 안전하게 공유할 수 있다.

***

# **6장. 자바에서 코틀린 컬렉션으로**

1. 자바는 코틀린에 전달한 컬렉션 내부를 변경할 수 있다는 사실을 인식하라
2. 자바가 코틀린으로부터 전달받은 컬렉션 내부를 변경할 수 있다는 사실을 인식하라
3. 자바 컬렉션을 사용하는 코드에서 컬랙션 내부 상태 변경을 제거하라
4. 상태 변경을 제거할 수 없는 경우에는 [방어적 복사](https://tecoble.techcourse.co.kr/post/2021-04-26-defensive-copy-vs-unmodifiable/)를 수행하라

## 노트

1. 메소드에서 암시적으로 컬렉션의 상태를 변경하지 말고 명시적으로 반환을 하자
   - `"어떤 데이터를 제자리에서 변경하는"코드 보단 "새로운 값을 계산하고 참조가 이 새 값을 가리키게 하는" 코드를 작성하자`

## 자바 컬렉션

> **에일리어싱 오류**를 디버깅하느라 인생 중 수백시간을 허비하고 난 뒤에야
> 
> 기본적으로 **불변 데이터**를 사용하는 게 더 낫다는 결론을 내리게 된다.
> 
> 자바 2 도입 이후에 변경 가능한 컬렉션 인터페이스를 사용하는 개발자의 경우에는 이런 상황에 처하게 된다.
> 
> `99p`

자바 10에는 컬렉션을 `AbstractImmutableList`로 복사해주는 `List.copyOf(collection)`이 생겼다.  
이렇게 만들어진 객체는 변경이 불가하고 원본과도 무관하다.  

하지만 이런 식으로 원본과 복사본을 고민해가면서 사용하는 것이 지겹고 실수하기도 쉽다.  

1. **공유된 컬렉션을 변경하지 말라**  
   - 서로 떨어진 두 코드 사이에 공유된 컬렉신여 있다면 이를 불변 컬렉션으로 취급하라  
2. **생성하되 변경하지는 말라**  
   - 참조를 결과로 반환하자마자 이를 불변 객체인 것처럼 취급해야 한다.  
3. **성능을 위해 컬렉션을 가변 컬렉션으로 공유해야 하는 경우에는 이름을 주의 깊게 붙이고 `accmulator`, 공유 범위를 최대한 제한하라**  

## 코틀린 컬렉션

코틀린 개발자는 자바 컬렉션 인터페이스에서 **상태를 바꾸는 메서드를 제거**하고, `kotlin.collections`패키지 안에서 `Collection<E>`, `List<E>`등의 인터페이스로 공개한다.  
그리고 이들을 `MutableCollection<E>`, `MutableList<E>` 등으로 **확장하면서 다시 상태 변경 메서드를 추가**했다.  

`java.util.List` ↔︎ `kotlin.collections.List` 서로 취급이 가능하다  
이 마법은 자바 `List`를 코틀린 `MutableList`로 취급할 수도 있게 해준다. (하지만 이런 짓을 하면 안된다.)  

**불변**, **일기 전용**, **가변**
- 가변이 아닌 코틀린 컬렉션에 대한 공식 용어는 불변이 아니고 **읽기 전용**이다.
- `UnmodifiableList` 인터페이스를 통해서 변경할 수는 없지만, 다른 방법으로 내용을 변경할 수는 있다.
- **진정한 불변 컬렉션**만 변경이 일어나지 않는다는 사실을 보장할 수 있다. `java.util.List.of(...)`
- 코틀린에서 일반적인 컬렉션 타입은 모두 불변 컬렉션 타입이고, 원소를 변화시킬 수 있는 경우에만 직접 가변 컬렉션으로 형변환을 하여 사용하는 방식을 채택했다
    - **소스 코드를 문서화하는 효과가 있다**

## 코틀린으로 변환하기 [예제 코드](https://github.com/jdalma/java-to-kotlin/commit/ca66a85a5f9c644e5bd44978c989e93a001515ae)

***

# **7장. 동작에서 계산으로**

**참조 투명성**  
프로그램에 어떤 함수가 있을 때 이 함수를 호출한 모든 부분에서 함수 호출을 그 함수 호출의 결괏값으로 치환해도 프로그램이 똑같이 작동할 때 이런 함수를 **참조 투명한 함수**라고 말한다.  

## 함수

이 책에서는 결과를 돌려주는 함수와 그렇지 않은 서브루틴, 객체와 연관이 되어 있든 함수 자체로 존재하든 관계없이 **함수**라는 용어로 가리킨다.  
- 함수가 특정 객체와 연관되어 있다는 점이 아주 중요한 경우에는 **메서드**라고 부르기도 한다.
코틀린의 `Unit`은 값이 없는 것이 아니라 **값이 없음을 표현하기 위해 항상 똑같은 싱글턴 값을 반환한다.**  

**실제로 함수를 나누는 더 유용한 방법은 `계산`과 `동작`으로 나누는 것이다.**  
코드가 동작인 동시에 계산일 수는 없고, 시간에 의존적인 동시에 독립적일 수는 없다.  
**어떤 계산 코드를 가져다 동작을 호출하게 만들면 해당 코드는 동작이 된다.**  

## 계산

함수가 계산이 되기 위해서는 **입력이 같을 때 항상 같은 출력을 반환해야만 한다.**  
- 따라서 같은 인자로 호출하면 항상 같은 결과를 돌려주는 함수가 계산이다.
- 확장 함수나 프로퍼티가 의존하는 데이터가 `값`인 경우에는 계산일 수 있다.

**데이터가 변하지 않는 경우에만 의존해야 한다.**  

## 동작

언제, 얼마나 많이 호출되느냐에 따라 결과가 달라지는 함수  
- 지역변수, 반환 값이 아닌 함수 외부에 영향을 끼친다는 점에서 **외부 효과**가 더 적절한 이름일 수 있다.
동작이 있으면 자유롭게 코드를 리팩토링 할 수 없다.  

**어떤 경우든 외부에서 관찰가능한 부수 효과가 있는 함수는 계산이 아니라 `동작`이다.**  
- `void`나 `Unit`을 반환하는 함수는 거의 항상 동작이다.
- 어떤 다른 변할 수 있는 데이터 소스로부터 데이터를 읽어서 결과를 돌려준다면 동작으로 분류할 수 있다.


## 추상 객체를 사용하여 `Immutable Collection`을 암시한다 ?


```java
public interface TripsJava {
    Set<TripJava> tripsFor(String customerId);
    Set<TripJava> currentTripsFor(String customerId, Instant at);
}
```

```kotlin
class InMemoryTrips : TripsJava {
    private val trips: MutableMap<String, MutableSet<TripJava>> = mutableMapOf()

    override fun tripsFor(customerId: String?) =
        trips.getOrDefault(customerId, emptySet<TripJava>())

    override fun currentTripsFor(customerId: String?, at: Instant?) =
        tripsFor(customerId)
            .filter { it.isPlannedToBeActiveAt(at) }
            .toSet()
}
```

TripsJava는 **불변 컬렉션**을 반환한다고 명시되어 있지만, 만약 `tripsFor()`에서 **가변 컬렉션**을 반환하면 어떻게 될까?  
**실제로 반환되는 하위 타입이 우선된다.**  

***

# **8장. 정적 메서드에서 최상위 함수로**

> 자바에서 독립 함수는 클래스의 메서드로 선언되어야 하지만, 코틀린에서는 최상위에 있는 존재로 선언이 될 수 있다.    
> 어떤 때 최상위 함수를 선호해야 하며, 자바에서 어떤 리팩터링을 통해 최상위 함수에 이를 수 있을까?

자바에서는 **클래스 수준의 인스턴스 캐시를 구현하기 위해 정적 필드를 사용하기도 했다.**  
정적 함수는 **그 함수가 작용할 대상 타입에 메서드를 추가하지 않고 기능을 추가하고 싶을 때 유용하다.**  
JVM은 실제로 진정한 최상위 함수가 아니라 정적 메서드만 지원한다.  

코틀린은 함수(그리고 프로퍼티와 상수)를 클래스 밖에 선언하도록 허용한다.  
JVM에서는 이런 함수를 둘 곳이 없으므로 **코틀린 컴파일러는 이런 최상위 선언을 넣기 위해 정적 멤버가 들어있는 클래스를 생성해준다.**  
컴파일러는 디폴트로 함수 정의가 들어있는 파일 이름으로 부터 클래스 이름을 파생시킨다.  
- `top-level.kt`안에 정의된 최상위 함수들은 `Top_LevelKt`라는 클래스 안의 정적 메서드가 된다.

`object 선언`은 싱글턴을 정의한다.  
`object`의 모든 멤버는 그 객체의 이름과 똑같은 이름의 클래스 안에 멤버로 들어가는데, `@JvmStatic`으로 지정하지 않는 경우 실제 정적 멤버로 컴파일 되지 않는다.  
- 코틀린은 싱글턴 객체가 다른 클래스를 확장하거나 인터페이스를 구현하도록 허용한다.  

**정적 멤버와 비정적 멤버를 한 클래스에 모아야 하는 경우**, 클래스 안에서 정적인 부분을 `companion object 동반객체`안에 위치시키면 된다.
동반 객체에 들어있는 선언은 해당 선언이 속한 파일 안에서 한 그룹으로 묶이며, 동반 객체의 멤버는 동반 객체가 속한 클래스 인스턴스의 비공개 상태에도 접근할 수 있다.  
- 동반객체도 다른 클래스를 확장하거나 인터페이스를 구현할 수 있다.

**따라서 코틀린에서는 인스턴스 영역의 함수가 아닌 함수들을 최상위 함수로 정의할 수도 있고, 싱글턴 객체의 멤버로 정의할 수 있으며, 이 싱글턴 객체는 동반 객체일 수도 있고 다른 타입에 속하지 않는 최상위 객체일 수도 있다.**  
이 세 가지가 모두 같다면 기본적으로 최상위 함수를 사용해야 할 것이다.    
- `MyType.of()`와 같은 팩토리 메소드는 동반 객체의 메서드로 함수를 정의해야 한다.

1. [`@file:JvmName("Shortlists")`](https://github.com/jdalma/java-to-kotlin/commit/09af98a03d8dfa2e390ef51286dd60aff983f4c9#diff-1044d609b913915ee4faa6e813de12d2a57582f596a0c236f2cce3d5eb03c23c)
   - **`import travelator.Shortlists.{method}` 이 형식으로 코틀린에서 코틀린으로 정의된 최상위 함수를 임포트할 수 없다.**
   - 코틀린의 입장에서 이 함수들은 패키지 안의 클래스 안에 정의되어 있지 않기 때문이다.
   - 코틀린 코드 컴파일 시점에 JVM에 `Shortlists`라는 클래스 안에 있는 정적 함수들을 알 수 없기 때문이다
   - 코틀린에서는 **`import travelator.{method}`** 이 형식으로 import 해야한다.

2. [`@JvmStatic`](https://github.com/jdalma/java-to-kotlin/commit/af61681c5e7b5847d16d653c3ac2ad48cce142f4)

3. [확장 함수로 변경](https://github.com/jdalma/java-to-kotlin/commit/e37139c4a733d79b61a250d80193d42d3a3b81e0#diff-1ffa997ca85179e20133c106e675d8ac5089c6e412ed5e5e480237295dc8e830)

***

# **9장. 문에서 식으로 (다중식 함수에서 단일식 함수로)**

> 단일식 함수를 언제, 왜 사용하는지 알아보고 어떤 코틀린 기능이 사용될까?  
> **단일식 함수를 계산에만 사용하라**  

식은 **선언적**이다.  
즉, 함수가 계산하는 값이 **무엇인지**선언하며 코틀린 컴파일러나 런타임 시스템이 그 게산을 수행하는 **방법**을 결정하도록 한다.  
코틀린에서는 대입이 문이지 식이 아니다.

1. [**Take 1 : 인라이닝**](https://github.com/jdalma/java-to-kotlin/commit/8cdfec4df37aaafccefe62451148298aacc8dc25)
   - `atIndex` 대입문을 인라이닝화
2. [**Take 2 : 새 함수 도입하기**](https://github.com/jdalma/java-to-kotlin/commit/64aa6db38a45ff2cbbf790bac36bcb4b9b289a6f) 
   - `emailAddress()` 함수로 추출
   - `parse()`는 단일식이 되었다.
   - `require`을 인라이닝하여 `when`을 사용해보자
3. [**Take 3 : `let`**](https://github.com/jdalma/java-to-kotlin/commit/5a6dc4a75c08bb685c5e9ddd5b4f573fa9f8802f)
   - Take 2에서 함수를 추출했던 이유는 `atIndex`값을 따로 지역 변수에 저장하지 않아도 블록 영역안에서 해당 값을 참조하고 싶어서였다.
   - 여기서 필요한 값이 하나뿐이기 때문에 `let`블록을 사용하면 함수를 정의하지 않아도 이런 영역을 만들 수 있다.
   - ```kotlin
     // [1] 이렇게 하면 let블록안에서 atIndex 지역변수를 가리킨다
     val atIndex = value.lastIndexOf('@')
     atIndex.let{
         // ...
     }
    
     // [2] 이렇게 람다 파라미터로 같은 이름을 지정하면 지역변수 대신 람다 파라미터 값을 쓰게 된다 
     atIndex.let{ atIndex -> 
         // ...
     }
    
     // [3] atIndex 지역 변수 인라이닝
     value.lastIndexOf('@').let { atIndex ->
         // ...
     }
     ```

4. [**Take 4 : 확장 함수 추가**](https://github.com/jdalma/java-to-kotlin/commit/52e42b38f2a5dac7376c3e604c035947da3aab4a)
   - 다시 처음으로 돌아가서 `atIndex`에 집중하지말고 `substring` 부분에 집중해보자
   - `split()` 함수를 최상위 함수로 추가


> **`parse()`가 무엇을 반환해야 할까?**  
> `parse()`에서 오류가 발생했을 때 예외를 던지지 않으면 리팩토링이 훨씬 더 쉬워진다는 점을 알아두자  
> `throw`는 `Nothing`을 반환하는 식이다. (Nothing은 함수나 식 계산이 값으로 끝나지 않는다는 사실을 드러낸다)    
> `EmailAddress?`를 반환하게 해서 실패시 null을 돌려주게 해도 될 것이다.  
> 하지만 이런 방식은 자바 클라이언트와 잘 들어맞지 않는다.  
> **자바에서는 타입 시스템이 널 가능성에 대해 경고해 주지 못하기 때문이다.**  
> 자바 클라이언트가 사라지면 예외를 던지는 부분을 제거해도 될 것이다.

함수를 단일식으로 표현하려고 노력하는 것은 잘 구분된 깔끔한 코드를 이끌어 주는 좋은 규범이 될 수 있다.  
**단일식 형태를 얻기 위해 보통 하위식을 별도의 함수로 분리한다.**  
함수 결과를 기술하는 식은 `컴퓨터가 결과를 얻기 위해 수행해야 하는 동작보다는 함수 파라미터를 기반으로 기술된다.`  

***

# [**10장. 함수에서 확장 함수로**](https://github.com/jdalma/java-to-kotlin/commit/71f665689fe08ee9228ff53ac24216eb33855bb3)

고전적인 객체 지향 언어에서는 `클래스에 메서드를 정의해서 객체가 메시지에 반응하는 방법을 정의`한다.  
함수형 프로그래밍에서는 `값을 사용해 함수를 호출함으로써 문제를 해결`한다.  

클래스를 **가능한 한 작게 유지하고 핵심이 아닌 연산을 외부 함수로 만드는 게 낫다.**  
확장 함수가 자신이 확장하는 클래스의 비공개 멤버에 대한 접근을 할 수 없다.  

확장 함수를 디컴파일 해보면 자바의 정적 메소드로 생성되어 **수신 객체는 파라미터로 받게 된다.**  
그래서 `this`가 `null`일 가능성이 있다.  

***

# [**11장. 메서드에서 프로퍼티로**](https://github.com/jdalma/java-to-kotlin/commit/fe2c9f8856275fc8745589aaf35820178ceab634)

**언제 계산된 프로퍼티를 선택해야 할까?**  
같은 타입에 속한 다른 프로퍼티에만 의존하고 계산 비용이 싼 경우에는 **계산된 프로퍼티를 택하라**는 것이다.  
계산 비용이 비쌀 경우에는 `lazy`키워드를 사용하는 방법도 있다.  

**자바에서의 프로퍼티 접근과 코틀린에서의 접근은 어떻게 다른가?**  
코틀린은 클래스의 필드 접근에 대한 결정을 개발자에게 맡기지 않고 `접근자 메서드만을 사용하여 접근하기로 결정`했다.  
- 정말 `public`필드가 필요하다면 `@JvmField`를 쓸 수 있다.


개인적인 생각으로는 `예제 11.2` 부터의 흐름은 `static Set<CampSite> sitesInRegion()`에 대한 메서드를 **확장 함수로 넓혀가는 작업이다**  
`예제 11.9`는 `Iterable<CampSite>`로 `CampSite`로 한정적이기 때문에 꽤 합리적인것으로 보인다.  

***

# **12장. 함수에서 연산자로**

> 시스템을 코틀린으로 점진적으로 변환해 나가는 과정에서 두 언어의 관습을 동시에 지원하려면 어떻게 해야 할까?

1. [`Money`클래스에 **산술 연산자 확장 함수**를 추가하는 방법](https://github.com/jdalma/java-to-kotlin/commit/23c2d5a197cb63ba3c0a2d809a1a4c075f3b3746)
   - `@JvmName`을 사용하면 코틀린과 자바에서 메서드가 다른 이름으로 불리게 할 수 있다.
2. [기존 코틀린 코드에서 정의한 연산자 호출하기](https://github.com/jdalma/java-to-kotlin/commit/461221605b65252e1db6c9fcf6c4e1f4f29a39ee)
   - 자바를 위해선 `add()`를 사용하고 코틀린에서는 `+` 연산자를 사용할 수 있게 `operator plus()`를 정의해놓는다.
3. [동반 객체 `operator fun invoke()`와 팩토리 메소드 `of()`를 통한 클래스 생성](https://github.com/jdalma/java-to-kotlin/commit/dc28a63b342303cc75037ce27d0ff19037e5f021)

> **팩토리 메소드에는 `두 가지 책임`이 있다.**  
> 1. 클래스를 생성하면서 클래스의 불변 조건을 강제하는 것
> 2. 값을 표현하는 객체를 생성하는 현대 자바 관습을 따르는 **설탕 문법**을 제공한다.

***

# **13장. 스트림에서 이터러블이나 시퀀스로**

> 코틀린이 자바 스트림 대신 무엇을 사용할까?  
> 어떻게 하면 자바 스트림을 이런 코틀린 구조로 변환할 수 있고, 언제 이런 변환을 수행해야 할까?

자바 스트림이 일반적인 컬렉션 변환, 지연 계산, 병렬 처리 등의 작업을 모두 염두에 두고 설계됐는데 이런 **작업의 요구조건이 모두 다르다는 점에 있다.**  
코틀린을 병렬 연산을 구현하려 시도하지 않고 **두 가지 추상화만을 제공한다.**  

첫 번째는 컬렉션 변환과 축약에 유용한 **이터러블**이고, 두 번째는 지연 계산을 제공하는 **시퀀스**다.  
코틀린의 시퀀스는 자바 스트림의 대체물이 아니다.  

`Stream.fillter`와 달리 코틀린 `Iterable.filter`는 `List`를 반환하기 때문에 함수 호출으 계속 연쇄할 수 있다.  

```kotlin
fun averageNonBlankLength(strings: List<String>): Double = 
    (strings 
        .asSequence() 
        .filter { it.isNotBlank() } 
        .map(String::length) 
        .sum() / strings.size.toDouble())
```

> 다만 모든 데이터를 읽기 전에는 작업하는 흉내조차 낼 수 없어서 **터미널 연산이 되어야 하는 `sum`함수**는 제외된다 (245p)      
- `sum` 함수는 `Sequence`를 반환하지 않는다는 뜻이다
  
> `Iterable<T>`의 확장 함수와 `Sequence<T>`의 확장 함수는 같은 파라미터를 받지만, 의미가 아주 다르기 때문에 서로 같은 유형의 연산이 아니다.  
> `Iterable`에 대한 연산은 **즉시 계산**이지만, `Sequnece`에 대한 연산은 **지연 계산**이기 때문에 이 둘을 아무 불이익 없이 바꿔 사용할 수는 없다  
> 반면 이들이 비슷한 API를 제공한다는 점은 이터러블과 시퀀스를 서로 전환하고 싶을 때 코드를 거의 바꾸지 않아도 된다는 사실을 의미한다.  

***

# **14장. 누적시키는 객체에서 변환으로**

> 가변 객체와 부수 효과에 의존하는 자바 코드를 불변 값을 변환하는 코틀린 코드로 바꾸는 가장 좋은 방법이 무엇일까?  


`CostSummary`와 `CostSummaryCalculator` 위주로 계산을 **가변 클래스에서 불변 데이터에 대해 작용하는 함수로 리팩토링해 보자**  
`CostSummary`를 불변 값 타입으로 만드는 것 부터 시작해서, `CostSummaryCalculator`까지 적용할 것이다.

1. [기준](https://github.com/jdalma/java-to-kotlin/commit/41b452d66ce7ed8fa89ee3d8378116cbccd38f80)
2. [제자리 정렬 수정, `apply` 적용해서 클라이언트가 객체 내부 필드를 추가하였다](https://github.com/jdalma/java-to-kotlin/commit/b824bb8e1fd0a366c9d4499d1a98e9c642db3e3c)
3. [부생성자 추가 및 `apply` 제거로 인해 객체 생성에 대한 책임은 스스로가 가지게 했다]()
4. [`fold`를 이용해 모두 불변 필드로 만들었다.](https://github.com/jdalma/java-to-kotlin/commit/95e1ac530589308d1400c868b5bb86985e3538d7)
5. [`data class`로 변경](https://github.com/jdalma/java-to-kotlin/commit/f9845e1a93628fc15c97df18535543080f6d3bf1)
   - 이 예제에서 `CostSummary`의 내부 필드를 계산기에서 다 계산하고 값을 전달해준다.
   - `CostSummary` 생성자에서 필요한 값을 받아 `CostSummary`가 직접 계산을 하여 스스로를 생성하여야 한다.

***

# **15장. 캡슐화한 컬렉션에서 타입 별명으로**

> 어떻게 해야 현재 설계에서 더 나은 설계에 도달할 수 있을까?

컬렉션을 도메인 타입으로 사용하는 것이 코틀린에서는 옳지만은 않다.  
**불변 컬렉션을 캡슐화하는 것이 규칙이 아니라 `예외`가 되어야만 한다.**  

새로운 기능을 추가하고 싶을 때 핵심 도메인 클래스가 모든 연산을 가져 코드 기반의 여러 부분이 결합되어 힘들 수 있다.  
- 클라이언트는 `Route`대신 `List<Journey>`에 대해 정의된 확장 함수를 통해 제공되는 연산을 사용하게 만들어야 한다.
- 실제로 컬렉션을 감싸는 클래스(`Route`처럼)는 불필요한 클래스가 아니라 나쁜 클래스다.  
  - 감싼 클래스를 벗겨낸 후 연산을 수행하고 다시 감싸야하는 불편함도 있다.
- 감싸는 클래스로 인해 처리할 때 **코틀린 표준 라이브러리가 제공하는 기능을 사용할 수 없기 때문이다.**
- `Route`가 `List<Journey>`를 **가지기를**원하지 않고, `List<Journey>` **이기를** 원한다. 

> "한 가지 데이터 구조에 사용할 수 있는 함수 100개가 열 가지 데이터 구조에 사용할 수 있는 함수 10개 보다 더 낫다."
> - [앨런 펄리스의 프로그래밍 격언](https://www.cs.yale.edu/homes/perlis-alan/quotes.html)

**타입 별명**을 사용하면 여러 문제들을 해결할 수 있다. (클라이언트 코드가 코틀린이어야 한다.)

***

# **16장. 인터페이스에서 함수로**

> 인터페이스는 계약의 두 당사자를 서로 결합시키기 때문에 소프트웨어가 더 유지보수하기 어려워진다.  
> 함수 타입이 이 문제를 어떻게 해결할 수 있을까?
    
클라이언트 코드가 구현 클래스만 의존하는 것 보다 인터페이스에 의존하게 하면 **각 구현체들의 설정과 구현 내용을 감출 수 있다.**  
**정보 은닉을 추구했지만 구현 은닉에 머문다.**  

**인터페이스를 익명으로 구현만 제공**한다면 클라이언트는 다운캐스팅을 하거나 다른 메소드를 호출하는 등의 조작이 불가능해진다.  
이 객체를 **클로저**라고 부른다.  
- 이 객체는 나중에 참조하기 위해 주변 문맥(함수 호출에서 전달받은 파라미터들)에서 자신에게 필요한 값들을 모두 감싸서 유지하기 때문이다.

```kotlin
fun interface Itest {
    fun printTest(message: String)
}

fun test(
    message1 : String,
    message2 : String
) = Itest {
        message ->(
        print(message + message1 + message2)
    )
}
```

위에서도 **람다가 자신을 둘러싼 함수의 파라미터 값을 포획하는 `클로저`이다.**  

> 객체지향 프로그래머가 어떤 기능의 성가신 세부 사항을 캡슐화해서 클라이언트가 그 기능을 사용할 때 마다  
> 세부 사항을 전달하지 않아도 되게 하는 문제를 어떻게 해결하는지 살펴봤다.  
> **함수형 프로그래머는 같은 문제를 어떻게 접근할까?**

함수형 용어에 **[부분 적용](https://en.wikipedia.org/wiki/Partial_application)** 이라는 기법이 있다.  
- **함수의 인자 중 일부를 고정시키면서 인자가 더 적은 새 함수를 만들어 내는 기법**
- 코틀린에서 **부분 적용**을 사용하는 가장 쉬운 접근 방법은 설정 정보를 일부만 적용하는 함수를 작성하는 것이다.  

> 함수적 해법과 객체 지향 해법을 하나로 합치는 한 가지 방법은 함수를 오직 **invoke라는 메서드만 제공하는 객체로 간주하는 것**이다.  
> 정확히 자바 8이 람다를 도입할 때 취한 전략이 바로 이 방법이다.  
> 함수 타입을 가리키기 위해 자바는 원하는 시그니처의 **단일 추상 메서드 Single Abstract Method (SAM) 인터페이스**를 사용한다.    
> 자바 람다는 SAM 인터페이스 (함수형 인터페이스 등)를 구현하기 위해 허용되는 특별한 문법이다.  
> 실제 람다 내부 구현은 **불필요하게 클래스를 정의하고 객체를 인스턴스화하는 일을 피하기 위해 더 복잡하다.**  

하지만 코틀린의 네이티브 함수 타입 문법은 **인터페이스 보다 함수 타입 활용을 더 장려한다.**  
코틀린 함수를 사용하면 자체 인터페이스를 사용하는 것보다 결합을 더 줄일 수 있으므로, **함수를 기본적으로 선택해야한다.**  


## 15,16장 모임

1. "정적함 함수의 발견 가능성이 낮다는 점" → Util성 정적 메소드들을 찾을 수 있다는 것은 `Arrays`를 생각한다는 자체가 지식으로 알 수 있는 것 처럼 찾기가 힘들 수 있다는 것
2. `data class`는 생성자로 받은 필드들을 `public`하게 사용하는 것이 일반적이다.
3. `typealias`와 확장함수에 회의적
   - `typealias`가 적용된 타입에만 확장함수가 적용되면 좋은데,
   - `typealias A = List<B>`로 사용하게 되면 `A`도 `List`의 모든 확장함수를 사용할 수 있다.
4. `List<Journey>`가 무슨 의미인지 알 수 없을만큼 사이즈가 커진다면,
5. "인터페이스는 계약의 두 당사자를 서로 결합시키기 때문에 소프트웨어가 더 유지보수하기 어려워진다." 317p
   - **인터페이스로 결합하던, 시그니처로 결합하던 어떤 방법이 유지보수에 좋다고 단정짓기는 힘들다.**
   - 어떤 코드든 수명이 있기 마련이기 때문이다.
6. 익명 클래스의 인스턴스는 언제 사용하나??
   - `compare`
7. [자유 변수](https://ko.wikipedia.org/wiki/%EC%9E%90%EC%9C%A0_%EB%B3%80%EC%88%98%EC%99%80_%EC%A2%85%EC%86%8D_%EB%B3%80%EC%88%98)와 클로저의 정의
   - 클로저의 정의는 3가지로 나뉜다.
   - **스코프(scope)에 묶인 변수를 바인딩 하기 위한 일종의 기술**은 `현상`으로 클로저를 정의한 것이다

***

# **17장. 목에서 맵으로**

> 목은 객체지향 코드와 프로덕션 의존 관계의 결합을 떼어놓는 일반적인 기법이다.    
> 코틀린에는 더 나은 기법이 있을까?

**[테스트로 인한 설계 손상](https://dhh.dk/2014/test-induced-design-damage.html)**와 이 책 저자는 **목은 테스트를 망친다**고 생각한다.  
- 예상되는 메서드 호출과 호출시 반환해야하는 내용을 기술하는 점
- 1번의 내용을 이해하기 어려울 때가 자주 있다
- 코틀린 코드 기반에서는 목이 없는 경우가 낫다 `왜??`
  
1. **[목을 맵으로 대체하기](https://github.com/jdalma/java-to-kotlin/commit/194149c38eaab92e631987689b349814e1b1032c)**
   - 함수 타입을 입력 파라미터와 결과를 연관시켜주는 매핑이라고 생각하면 된다.  
   - `mock`이 적용된 부분을 `MutableMap`으로 변경하자
2. **[그렇지만 실제 목에서 벗어났는가?](https://github.com/jdalma/java-to-kotlin/commit/42c8c7881bbce3ddce328b5faca395093ba706b5)**
   - 입력과 출력이 명확히 대조되는 테스트로 바꿨다
   - **데이터에 집중하면 테스트가 단순해진다는 사실을 알 수 있다.**
3. **[지영](https://github.com/JIY0UNG)님이 작성하신 [계층형 테스트 코드](https://gist.github.com/JIY0UNG/4b2b508d4313482e5807f768a23923db)**

***

# **18장. 열린 클래스에서 봉인된 클래스로**

> 자바에서 명사는 클래스와 인터페이스로 표현되고, 동사는 메서드로 표현된다.  
> 하지만 코틀린은 봉인된 클래스 계층과 독립적인 함수를 추가했다.  
> 이들이 명사와 동사들의 협력에 어떤 가능성을 가져왔을까?  

데이터 타입과 함수의 변경 가능성 사이의 긴장을 가장 가깝게 느낄 수 있는 부분은 **도메인 모델의 핵심 엔티티**이다.  

`ItineraryItem` 인터페이스에 필드들을 선언하고 구현체들은 그 필드들을 `get()`으로 구현했다.  
- `Attraction`
- `Journey`
- `Accomodation`
- `RestaurantBooking`
  
하지만 코틀린에는 **클래스를 조직화하고 런타임 타입 검사를 더 안전하고 편리하게 해주는 기능인 `봉인된 클래스`가 있다.**  
- 직접적인 하위 클래스가 고정되어 있는 추상 클래스다.
- 봉인된 클래스 하위 클래스를 같은 컴파일 유닛과 패키지 안에 정의해야 한다.
다형성 메서드와 비교할 때, 봉인된 클래스와 `when`식은 **고정된 타입 계층에 적용할 새 연산을 쉽게 추가할 수 있게 해준다.**  
  
**데이터 타입에 적용할 수 있는 연산보다 데이터 타입이 더 자주 변경될 때 객체 지향 다형성이 적합**하며,  
**데이터 타입에 적용할 수 있는 연산이 더 자주 변경될 때 봉인된 클래스 계층이 더 적합**하다.  

> **봉인된 클래스 계층에서는 다운캐스트만 사용하라**  
> `List` 타입으로 받은 인자를 `MutableList`로 다운 캐스트해서 변경하는 함수는 호출하는 쪽의 예상을 위배한다.  
> 상위 타입을 하위 타입으로 변환할 수 있다는 사실이 그런 의도를 가져도 된다는 뜻은 아니다.  
> 봉인된 클래스 계층은 **다운 캐스트**가 목적이고, 다운 캐스트를 지원하며, 컴파일러의 완전성 검사에 안전하다는 사실을 알려준다.

**[인터페이스를 봉인된 클래스로 변환하기](https://github.com/jdalma/java-to-kotlin/commit/ff8792e7f64be2090f25c94456ad9662c93e32f8)**  
- `ItineraryItem`인터페이스에 메서드를 더 추가해서 애플리케이션 도메인의 핵심 클래스와 외부 모듈 사이의 결합을 높히고 싶지 않다.
- 봉인된 클래스 계층과 독립적인 함수를 처리하는 다형적 메서드의 인터페이스로 만들고, 독립적인 함수를 해당 함수를 사용하는 모듈로 옮기자
- `ItineraryItem.mapOverlay` 확장함수는 `ItineraryItem`의 모든 구현이 **MapOverlay**에 대해 알아야만 하는 필요성을 없애기 위해서다.
  - 하지만 위의 리팩토링에서 하위 구현체가 `MapOverlay`를 구현하지 않은 상태에서 `ItineraryItem.mapOverlay`를 사용하면 무한루프에 빠진다.
- 이와 같은 방법으로 `ItineraryItem`안에는 핵심 프로퍼티인 `Id`만 남게한다.
  

추상 계층을 확장한 케이스를 포용하는지 `when`을 사용해서 확인할 수 있고, 특정 클래스로 **다운 캐스팅**해서 작업을 명시해줘야 한다면 `sealed class`가 적절할 것이다.  

***

# **19장. 예외 던지기에서 값 반환으로**

> 코틀린은 체크 예외를 자바와 마찬가지 방식으로 언어 안에 넣지는 않는다.  
> 왜 코틀린이 자바의 접근 방법을 따르지 않았는지, 어떤 방법을 써야하는지 알아보자

어떤 연산이 실패할지를 알지 못하고, 실패할 때 어떤식으로 실패할 수 있는지에 대해서도 알지 못한다.  
실패를 아는 경우라 해도, 오류를 처리하는 방법에 대한 코드와 문제를 감지하는 코드가 멀리 떨어져 있을 수도 있다.  

> **Happy Path** : 개발자가 생각하는 정상적인 경우를 따라 흘러가는 프로그램 경로를 뜻한다.  

## 예외 이전의 오류처리

1. **오류 무시하기**
   - 영속적인 데이터를 오염시키거나 작업을 조용히 실패하게 되기 때문에, 우리는 더 높은 수준을 노려야 한다.
2. **그냥 프로그램 종료하기**
3. **특별한 값 반환하기**
   - 함수를 호출하는 쪽에서도 특별한 값을 반환하는 관습을 알아야 하기 때문에 번거롭다.
   - 해당 전략의 특별한 경우로 널을 반환하는 방식이 있지만 널 가능성을 명시적으로 확인하지 않으면 NPE가 던져지므로, 이 예외가 원래의 오류보다 더 나쁠 수도 있다.
   - **코틀린의 컴파일러는 호출자가 널 가능성을 처리하도록 강제하기 때문에, 이런 기법이 안전하고 효과적인 기법이 될 수 있다.**
4. **전역 플래그 설정하기**
   - 이 기법은 C에서 유명했지만 대부분은 예외 기반의 오류 처리로 대체됐다.
5. **상태 코드 반환하기**
   - 함수가 아무값도 반환하지 않고 오직 부수 효과만을 위해 존재하거나, 값을 다른 방식으로 반환하여 참조로 전달되는 파라미터를 변경하는 방식을 쓸 때 이런 전략을 선택할 수 있다.
6. **특별한 함수 호출하기**
   - 문제가 감지되면 오류 함수를 호출하여 오류를 표현하는 값을 파라미터로 전달한다.
   - 이 기법은 전략 패턴을 오류 처리에 적용한 예다.

## 자바와 체크 예외

자바 설계자들은 메서드가 던질 수 있는 예외들을 메서드 시그니처에 포함시켰다.  
자바 설계자들은 검사 예외 외에 **오류**와 **런타임 예외**로 예외 타입을 구별했다.  
자바 체크 예외의 마지막은 자바 8에 도입된 람다였다.  
람다를 지원하기 위해 도입된 **함수형 인터페이스**의 시그니처에 예외를 선언하지 않기로 결정했고, 그에 따라 람다나 함수형 인터페이스는 체크 예외를 전파할 수 없게 됐다.  
- 체크 예외를 [고차 함수](https://ko.wikipedia.org/wiki/%EA%B3%A0%EC%B0%A8_%ED%95%A8%EC%88%98)와 함께 사용하기는 어렵기 때문이다.
  
체크 예외는 JVM의 특성이 아니고 자바 컴파일러의 특성이기 때문에, 코틀린은 상당수의 체크 예외를 무시할 수 있다.
- 특별하게 취급하지도 않는다.
      
**오류**
- `java.lang.Error`의 하위 클래스는 실행 시점에 JVM의 올바른 동작을 보장할 수 없는 심각한 실패를 위해 예약되어 있다.
- 어디서든 이런 식으로 실패할 수 있으므로 이런 예외를 모든 함수 시그니처에 추가하는 것은 아무 가치가 없다.
  
**런타임 예외**  
- 프로그래머의 실수에 따라 문제가 발생할 수 있으므로 꼭 선언해야 하는 대상에서 제외됐다.

## 예외를 넘어서 : 함수형 오류 처리

왜 함수형 프로그래머들이 예외를 좋아하지 않을까?  
함수형 프로그래밍만의 특색있는 기능으로 **참조 투명성**이 있다.  
- 그 식을, 그 식을 계산한 결과로 안전하게 치환할 수 있다.
- `7.2절 계산`에서 살펴본 개념이 참조 투명하다.
  
`secondsIn(today())` 이 코드는 오늘 실행한 때와 어제 실행했을 때 서로 다른 결과를 내놓기 때문에 참조 투명하지 않다.  
어떤 식이 참조 투명하면, 그 식을 그 식을 계산한 결과로 안전하게 치환할 수 있다.  
프로그램의 행동 방식에 대해 추론하기가 훨씬 더 쉽기 때문에, 참조 투명성에 관심 가져야 한다.  
  
### **오류를 처리해야 하는 경우 어떻게 해야 참조 투명성을 달성할 수 있을까?**  

`parseInt()`는 `Int`만을 반환한다면 참조 투명하다고 볼 수 있지만, 문자열이 들어간다면 **예외**가 던져지므로 **참조 투명성을 깬다.**  
- 반환 타입은 `Int`인데 예외 타입은 `Exception`이기 때문이다.
  
특별한 값을 반환하는 오래된 기법으로 돌아가 참조 투명성을 회복할 수 있는 방법은 없을까?  

```kotlin
sealed class Either<out L, out R>

data class Left<out L>(val l: L) : Either<L, Nothing>()
data class Left<out R>(val r: R) : Either<Nothing, R>()
```
- 코틀린에서는 이런 경우 봉인된 클래스가 잘 어울린다.
  - **우리 자신만 하위 타입을 정의할 수 있고, 아무도 다른 하위 타입을 추가할 수 없기 때문이다.**
  
위와 같이 `Left`와 `Right`의 값들을 오류와 값으로 구분하여 사용할 수 있다.  
  
## **예외를 오류로 리팩토링하기**  


1. [시작](https://github.com/jdalma/java-to-kotlin/commit/dd8d0233897776d81ed916af8efc7c748096d9f8)
2. [Result4K 맛보기](https://github.com/jdalma/java-to-kotlin/commit/d39d490040b34bccc3e58f6ab96179c02ba206ff)
   - 코드를 그냥 코틀린으로 변환하면, 체크 예외의 장점을 읽어버리게 된다.
   - 따라서 예외 기반의 오류 처리를 Result4k를 사용한 함수형 대안으로 치환할 것이다.
3. [Result4K 적용](https://github.com/jdalma/java-to-kotlin/commit/4e56a012d00e7b25f29eb21b7685310f897f113c)
   - 각 계층의 예외들을 **봉인 클래스로 캡슐화**하여, 실패 모드를 열거해본다.
   - 봉인된 클래스로 만들면 컴파일 시점에 어떤 하위 타입이 존재하는지 알고 어떤 오류를 처리해야 하는지에 대해서도 알 수 있다.
  
> 1. **if**를 **when**으로 치환하기
> 2. 반환문을 **when**식으로 치환하기
> 3. 모든 **when**가지에서 중괄호 제거하기
  
체크 예외에 의존하는 자바 코드를 코틀린으로 변환하고 싶거나, 자바를 코틀린으로 변환하는 과정에 **오류 처리를 더 얹고 싶다면** `결과 타입을 사용하는 것이 가장 나은 전략이다.`  
연산이 여러 가지 방식으로 실패할 수 있다면 봉인된 클래스를 사용해 실패 모드를 열거할 수 있지만, 그 대가로 여러 계층에 같은 오류 타입을 전파할 수는 없게 된다.
이 책을 쓴 저자는 체크 예외를 좋아하지만 람다의 시그니처에 예외 정보가 표현되어야 하기 때문에 포기했다.  
  
**질문**  
1. "IOException을 조용히 삼켜 버리고 그 대신 나중에 RuntimeExceptions을 발생시킨다" 404p
   - 커스텀 예외가 체계적인 연결 문제를 드러내거나 저수준 코드에서 NPE가 발생한다는 사실을 감출수도 있기 때문이다
2. 19장의 의도는 참조 투명성을 유지하면서 예상되는 예외들과 예상 못하는 예외를 구분하기 위해 커스텀 예외를 Result4k를 사용하여 구분한걸까?

  
## 19장 모임
- `throw Throwable("aaa")`를 쓰지말고 함수 `err("aaa")`를 써라
    - **변경 가능성 대비**
- **Nothing**을 적극적으로 활용할 방안을 찾아라
- 런타임 예외라는 것은 어느 수준에 걸어야할까? 비즈니스 로직에서 런타임 예외가 발생할 수 있는데 모든 함수에 `try...catch`를 걸진 않는다.
    - 그렇다면 베이직인 체크 예외로 돌아가야하지 않을까?
- `Result`나 `Either`를 쓰는 경우도 있다
    - 러스트는 `Result`가 컴파일 레벨로 존재한다. 컴파일 시점에 분기문으로 변경된다.
- `Result4k`의 `recover()`처럼 라이브러리를 작성한 사람이 분기를 가져갔다.
    - 사용하는 입장에서는 함수를 넘겨서 처리할 수 있다
- 맹대표님은 내부에서 예외를 핸들링 하는 로직을 무조건 람다로 넘기게 한다
    - 이렇게 하면 장점이 예외를 처리할 수도, 안할 수도, 연산이 다 끝나고 처리할 수도 있다.

```kotlin
jsonParse(string)?. let{ 정상이면 널이아니지
    it.xxxx 파싱된 json으로 뭔가하기
}

jsonParse(string)?. let{ 정상이면 널이아니지
    it.xxxx 파싱된 json으로 뭔가하기
} ?: 잘못되었단다

fun jsonParse(string, ((report)->Unit)?):Json?
```

- 코틀린에서는 `null`을 타입으로 표현할 수 있어서, `null`을 잘못된 값으로 처리하기 수월하다.
- [모나드와 함수형 아키텍처](https://teamdable.github.io/techblog/Moand-and-Functional-Architecture)
- 맹대표님과 오이사님은 `Eiter`와 `Result`에 굉장히 회의적
- `Throw`를 쓰는 것과 `return`을 쓰는 것의 차이
    - `Throw`는 개발자가 제어 흐름을 가질 수 없고, `return`을 쓰는 것은 제어 흐름을 가질 수 있다.
    - `try...catch`는 제어 흐름을 잘 제어하기가 힘들다
- `Nothing`은 어떤 클래스보다 자식이라는 것을 의미한다
    - 제네릭 타입 사이의 관계를 정의하는 것이 **공변**, **반공변**이다.
    - `out T` 였으면 `Nothing`
    - `in T` 였으면 `Any?`

```
List<Int> List<Number>
Left(3)
Either<Int, String>
class Left<L>(..):Either<L,String>
val a:Either<Int,String> = Left(3)  // 가능
val a:Either<Int,Int> = Left(3)     // 불가능
val a:Either<Int,어떤타입이든> = Left(3)
Left는 원래 R에는 관심도 없음
```

- `map`은 각 개별 원소를 내부를 들여다보지 않고, 뜯어보지 않고, 꺼내지 않고 동작을 집어 넣어서 연산할 수 있는 장점이 있다.
  - `map`을 정의할 수 있는 함수는 **Functor**라고 한다
  - **미리 연산을 계획, 시나리오를 만드는 연산을 정의해놓는 것이 함수형 프로그래밍의 이점이다.** 
- **모나드**를 쓰는 대표적인 이유 `예외 처리`, `I/O 처리`

***

# **20장. I/O 수행에서 데이터 전달로**

> I/O는 동작이기 때문에 이에 대해 추론하거나 코드를 리팩터링하는 능력을 제한한다.  
> 어떻게 하면 이런 문제의 영향이 미치는 영역을 제한할 수 있을까?

I/O 동작의 부수효과가 미치는 영역을 지역 변수로 제한함으로써 이를 계산으로 변환할 수 있다.  
**I/O 발생 장소를 프로그램 진입점에 가깝게 옮기면 옮길수록 쉽고 멋진 계산으로 처리할 수 있는 부분이 더 많아진다.**  
  
1. [시작 예제](https://github.com/jdalma/java-to-kotlin/commit/d64b0f352fcce59672616f0f724b9ae2c0769a59)
2. [20.2 테스트 코드 코틀린으로 변환](https://github.com/jdalma/java-to-kotlin/commit/ec40b1c7c06ccb965fa8df2310d76531328f1045)
3. [20.2 `generate()` 리팩토링](https://github.com/jdalma/java-to-kotlin/commit/02045565424f1da46e5ec0a070b7888f6ac3dbb8)
   - `generate(reader: Reader, writer: Writer)` 기존에는 `writer`에 `reader`를 읽어들여 함수 내부에서 조작한다.
   - **첫 번째.** `reader: Reader`를 `lines: List<String`으로 리팩토링
   - **두 번째.** `generate()`함수를 `Writer`의 상태를 변경하는 대신 `List`를 반환하게 수정
4. [20.2 확장 함수 `toValuableCustomers()` 리팩토링](https://github.com/jdalma/java-to-kotlin/commit/85b7bfe0adc176c1a6d6598243334f95d6fef533)
   - 확장 함수 `toValuableCustomers()`는 `generate()` 내부로 흡수됐다.
5. [20.3 ~ 20.4 중간 컬렉션 생성을 연기하기 위한 `Sequnece` 적용](https://github.com/jdalma/java-to-kotlin/commit/d9f47e3dcf2e01297133d30c9ef1b193503867f6)
   - `in`또는 `out`을 **백틱**으로 감싸는 이유는 `in`이 키워드로 이미 존재해서 그런건가??
   - 현재 전체 입력을 메모리에 읽어오고 처리한 후, 전체 출력을 메모리에 만들어서 `OutOfMemoryError`가 발생할 경우가 있다.
   - `generate()` 함수를 확인해보면 `joinToString()`을 사용해 **거대한 문자열을 만들어냈다.** (이 시점에 출력의 각 줄과 이들을 합친 문자열이 동시에 메모리를 차지한다.)
   - **메모리 부족을 피하려면 중간 컬렉션 생성을 연기하기 위해 `Sequence`를 사용해보자**
     - `Sequence`가 이터레이션될 때 마다 한 번에 한 줄씩 출력을 만들게 되며, 전체 파일을 다 쓸 때까지 각 줄의 내용을 메모리에 유지하는 대신 빠르게 페기할 수 있다.
   - 클라이언트에서 `Sequence`를 넘기기로 변경
  
이번 장에서의 핵심은 `I/O 작업`의 책임을 호출자에게 넘기도록 리팩토링 한것이다.  
추가로 `List`를 `Sequence`로 변경하면서 지연계산을 활용하였다.  

***

1. 20.22와 20.24에서 joinToString()을 사용한 부분
2. 멀티 쓰레드 프로그래밍에서는 스레드가 작업할 때 혼자 독점하기보다는 딜레이나 sleep을 통해 제어권을 넘겨줘야한다.
3. 함수 파라미터 순서는 중요도로 따진다.
4. 코드를 함수나 메서드로 분리하는 경우는 변화율이 서로 다를 떄 이다.
   - 변화율은 어떻게 측정할 수 있을까? 도메인 지식? 기획 의도를 철저하게 이해하는 것?
5. 어떻게 하든 분기문은 줄어들지 않는다. 맹대표님은 분기문 만큼의 기능을 분리해서 클라이언트에서 전략 객체를 선택하게 하는 방법을 쓴다.
   - 분기문이 등장하는 이유는 도메인 때문이다.
6. [`Sequence<T>.asSequence()`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/as-sequence.html) 용도가 뭘까?
   - `return this`?? ㅋㅋㅋㅋ
7. [`Sequence<T>.chunked(size: Int)`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/chunked.html)
8. `groupingBy`와 `groupBy`차이
9. **함수형(계획적) 프로그래밍은 파이프라인을 까는것이다.!!!!!**
10. 아래의 `+`는 `Sequence<T>.plus`

```kotlin
return sequenceOf("\"ID\\tName\\tSpend\"") +
        valuableCustomers.map (CustomerData::outputLine) +
        valuableCustomers.summarised()
```

***

# **21장. 예외에서 값으로**

> 코틀린에서는 힌트를 제공하는 체크 예외는 없고, 체크 예외를 사용하는 방식은 나쁘므로  
> 20장의 코드를 되짚으며, 발생할 수 있는 예외를 처리해보자

문자열 파싱 부분이나 숫자 변환 시 발생할 수 있는 예외들은 "프로그램을 중단시켜야 할까?", "오류 메시지를 개선해야 할까?"  
**19장에서 본 것처럼, 예측할 수 있는 오류가 발생했을 때 프로그램을 중단하기 위해 예외를 써서는 안된다.**  
- 프로그램을 중단시키기 위해 예외를 사용하면 코드가 실패할 수 있다고 알려줄 기회가 사라진다.  
- 코드가 이런 예외를 던지면 코드를 호출하는 쪽에서는 구현 코드를 한 줄씩 살펴보면서 오류 원인을 추론해야 한다.  
- 추론했다 하더라도 구현이 바뀌면 쓸모없게 된다.
  
호출하는 입장에서는 실패시 `null`을 반환하면 `null`이 발생할 경우를 고려할 수 있다.  
- 코틀린 표준 라이브러리는 `XXX::toXXXOrNull`을 제공한다.
  
1. [문제가 될 수 있는 라인을 별도 리스트에 저장](https://github.com/jdalma/java-to-kotlin/commits/main)
   - 문자열 파싱 후 사이즈 확인 및 숫자 변환 시 발생할 수 있는 예외들 
2. [예외 발생 시 널 허용이 아니라 예외를 포함(`Result 사용`)하게 수정](https://github.com/jdalma/java-to-kotlin/commit/8089c986ba9cbaeadd990cd56663c07d9afb7040)
3. [`Reader`, `Writer`, `Error` 인라이닝 함수 적용](https://github.com/jdalma/java-to-kotlin/commit/43de210f5f4cab81402a816166d329bd7fca0fdf)
  
**에상하는 예외**는 잡아서 처리하고, **예상하지 못한 예외**는 `try...catch`로 감싸서 의미있는 내용을 전달하는 것이 좋다.  
📌 **동작이나 오류를 일으키는 코드를 진입점에 가깝게 옮겨서 이들이 오염하는 시스템 영역을 최소화하라**  
  
***

# **22장. 클래스에서 함수로**

> 객체 지향에 적응되어 있다면 타입을 만들어서 문제를 해결하는데 능숙하다.  
> 함수형에 적응되어 있다면 기존 타입에 함수를 덧붙이는 데 익숙하다.  
> 새 타입을 정의하지 않고 어디까지 적용할 수 있을까?

1. [인수 테스트 코드 작성](https://github.com/jdalma/java-to-kotlin/commit/6413e231135048d28a0b4331e7db577be2196fb7)
   - 필요한 인터페이스와 타입이 정해졌다.
   - 테스트 주도 개발을 따르면, **구현을 변경해야 할 이유가 되는 테스트를 먼저 추가해야 한다.**
2. [단위 테스트](https://github.com/jdalma/java-to-kotlin/commit/ab7b764d9526d1a3b44dad356c42b84e274b0d45)
   - 책의 흐름은 TDD로 진행했다.
   - 설계 기법으로 TDD를 사용한다면 **최종 테스트가 프로그램의 올바름을 검증**하고 **문서화를 제공**하고 **퇴행을 막는지 확인을 하는 일**이라는 것을 명심해라
   - `"신뢰하되 직접 검증하라!"`
3. [다른 필드 구분자를 위해 구분자에 대한 추상화](https://github.com/jdalma/java-to-kotlin/commit/3901499c9fe56a2bc39193598acb3241c7bc7ad3)
   - `"처음부터 함수 타입을 언어에 포함해 설계된 코틀린의 경우 개발자들이 이런 추상화를 사용할 준비가 더 많이 되어 있다."`
   - `splitter` 람다 함수를 호출자 지정해줄 수 있게끔 파라미터화하고 기본 함수를 지정해놓는다.
   - 주요 로직의 일부분들을 람다 함수로 치환하여 호출자가 선택하게끔(전략 패턴)하는 것이 인상 깊다.
4. [시퀀스 적용](https://github.com/jdalma/java-to-kotlin/commit/0566b489db90a9ac68badd55750d12797ddbd0ef)
   - 현재 `readTable()`의 메모리 사용량은 입력 바이트 크기의 두 배이다.
   - **큰 파일을 처리하려면 리스트 대신 시퀀스를 사용해 작업하는 편이 더 좋다.**
   - 필요한 경우 **시퀀스는 각 파이프라인 단계에서 한 번에 한 항목만 메모리에 유지할 수 있기 때문이다.**
5. [시퀀스 멀티 콜 해결 및 테스트 코드 수정](https://github.com/jdalma/java-to-kotlin/commit/86fa8b17f425d3eebb2e95048406bc41d4351fbf)
6. [Apache Commons CSV와 비교](https://github.com/jdalma/java-to-kotlin/commit/9bf15cbe267e61007fd14089fbf737a87b1c8983)
   - 우리는 헤더가 있는 파일과 그렇지 않은 파일을 위해 두 가지 서로 다른 함수를 제공하지만 아파치 API는 `CSVFormat`에 이런 정보를 밀어넣는다.
   - `CSVFormat`은 줄을 분할하는 방법 외에 이스케이프 규칙, 빈 줄 처리 방식 등의 전략이 담긴 꾸러미다.
   - 람다에도 확장함수가 가능하다.
   - `Sequence<Map<String, String>>`을 `Table`클래스로 리팩토링 (headers, records, by키워드) 
   
  
`시퀀스 다중 이터레이션` 문제를 만났다.  
```kotlin
@Test
fun `read from reader 다중 이터레이션`() {
    val fileContents = """
        H0,H1
        row0field0,row0field1
        row1field0,row1field1
    """.trimIndent()
    StringReader(fileContents).useLines { lines ->
        val result = readTableWithHeader(lines).toList()
        assertEquals(
            listOf(
                mapOf("H0" to "row0field0", "H1" to "row0field1"),
                mapOf("H0" to "row1field0", "H1" to "row1field1")
            ),
            result
        )
    }
}

fun readTableWithHeader(
    lines: Sequence<String>,
    splitter: (String) -> List<String> = splitOnComma
) = when {
    lines.firstOrNull() == null -> emptySequence()
    else -> readTable(
        lines.drop(1),
        headerProviderFrom(lines.first(), splitter),
        splitter
    )
}
```

이유는 `readTableWithHeader`의 `firstOrNull()`에서 시퀀스를 소비하기 때문이다.  
`Sequence`가 비어있는지 살펴본 후 나중에 그 `Sequence`는 사용할 수 없다.  
`Sequence`를 사용하려면 파일을 전부 메모리에 적재하거나 파일을 두 번 읽지 않고도 파일의 첫 줄과 나머지를 `Sequence`에서 읽어올 수 있는 방법을 찾아야 한다.  
- 모든 데이터를 메모리에 적재하지 않으려 `Sequence`를 선택하였으니 후자를 택한다.
  
**`Sequnce`를 소비하지 않고 안에 원소가 들어있는지 어떻게 확인할 수 있을까?**  
실제로 `Sequence`를 소비하는 대상은 `iterator()`이다.  

```kotlin
/**
 * Sequence가 비어있을 때 null을 반환
 * 비어있지 않으면 머리와 꼬리의 Pair를 반환한다.
 */
fun <T> Sequence<T>.destruct() : Pair<T, Sequence<T>>? {
    val iterator = this.iterator()
    return when {
        iterator.hasNext() ->
            iterator.next() to iterator.asSequence()
        else -> null
    }
}
```

```kotlin
@Test
fun `double call sequence`() {
    val strings = listOf("A", "B")
    val sequence = sequenceOf("A" , "B")
    val destruct = sequence.destruct()

    destruct?.let { (first , second) ->
        assertEquals("A", first)
        assertNotEquals(strings, second.toList())
    }
}
```

위의 테스트 코드를 보면 `desturct`된 `second`는 `"B"`만 있다.  

***

# **23장. 여행은 계속된다**

대부분 코틀린은 자바를 기술하는 다른 문법을 제공하며 프로그래밍에 대한 접근 방식을 바꾸지 않아도 자바보다 타이핑을 적게 하면서 더 많은 일을 하게 해주는 언어인 것처럼 말한다.  
코틀린의 **스위트 스폿**을 찾으려면 자바보다 **함수적인 사고방식이 필요하다**.  
  
코틀린의 결과 자바의 결은 다르다.  
자바는 가변 객체와 리플렉션을 선호하며 합성성과 타입 안전성을 (가변성과 리플렉션에 대한) 대가로 지불한다.  
코틀린은 불변 값을 변환하는 것과 독립적인 함수를 선호하며, 비침투적이고 도움이 많이 되는 타입 시스템을 제공한다.
  
## **함수형 사고라는 말이 무슨 뜻일까?**

함수형 프로그래머들은 **변이를 줄여서 복잡도를 길들인다.**  
함수 안에서 컬렉션이나 변수를 변경하는 일은 **effect**지만, **변경한 내용이 함수 밖으로 공유되지 않으면 effect가 아니다.**  
어떤 effect가 결과를 미치는 영역이 함수에 지역적이면 시스템이 어떤 일을 하는지에 대해 추론할 때 effect에 대해 고려할 필요가 없다.  
공유된 상태를 변경하기 시작하면 **지역적인 효과가 공유된 상태를 볼 수 있는 모든 영역에 영향을 끼치게 되고, 복잡도가 빠르게 늘어나서 코드를 이해하기가 더 어려워진다.**  
함수형 프로그래밍에는 더 많은 내용이 포함되지만, **상태 변경이 없이 (상태 변경이 불가피하면 범위를 최소화하면서) 문제를 해결하는 것에 초점을 맞추면 이해하기 빠른 코드를 작성할 수 있다는 것이다.**  
- [Once And Only Once](https://wiki.c2.com/?OnceAndOnlyOnce) , [`D`on't `r`epeat `y`ourself](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)
  
코드를 더 어렵게 만들지 않으면서도 변이를 관리하는(그리고 중복을 제거하고, 테스트를 쉽게하는 등의) 기법을 배워야하고, 이런 기법이 보며인 어떤 기법인지 알아 볼 수 있는 안목을 키워야 한다.  
- *토비의 스프링에서도 이런 비슷한 말을 본 것 같다.*

코틀린은 기본적으로 클래스 상속에 닫혀있고, 합성적인 스타일을 장려한다.  
메서드를 오버라이딩하는 대신 전략이나 협력자를 표현하는 함수 타입의 프로퍼티를 사용한다.  

> 텐트 두 채를 설치하고 양쪽을 오갈 수 있는데 굳이 한 쪽 진영에만 머물어 있어야 할 이유는 없다.

함수형 프로그래머들은 다이어그램이나 시각화에 초점을 맞추지 않는다. 함수형 프로그래밍의 목표는 **대수적 추론**이다.
- 프로그램 텍스트를 조작해 프로그램의 행동 방식을 추론하는 것을 뜻한다.
- [모두를 위한 대수적 효과](https://overreacted.io/ko/algebraic-effects-for-the-rest-of-us/)
  
**참조 투명성**과 **정적 타입**을 사용하면 소스 코드 구문만 사용해 프로그램에 대해 추론할 수 있다.  


## **단순한 설계**

1. 테스트를 통과한다.
2. 작성자의 의도를 드러낸다.
3. 중복이 없다.
4. 최소한의 구성 요소로 이뤄진다.
5. 동작이 오염시키는 코드의 범위를 최소화 한다.

## **리팩터링**

4.2절에서 `확장과 축소 리팩터링`을 적극 활용해라.    
테스트 코드와 마찬가지로 훈련해야 한다.  
